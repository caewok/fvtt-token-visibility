<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evenly Distributed Points on a Sphere</title>
    <style>
        body {
            margin: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            color: #e0e0e0;
            background-color: #1a1a1a;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #controls-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(40, 40, 40, 0.8);
            padding: 15px 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            gap: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        label {
            font-weight: 500;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 200px;
            height: 8px;
            background: #444;
            border-radius: 5px;
            outline: none;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #007aff;
            border-radius: 50%;
            border: 3px solid #1a1a1a;
            cursor: pointer;
            transition: background 0.2s;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #007aff;
            border-radius: 50%;
            border: 3px solid #1a1a1a;
            cursor: pointer;
            transition: background 0.2s;
        }
        #info {
            font-size: 1.1em;
            font-weight: 600;
            min-width: 150px;
            text-align: center;
            background: rgba(0,0,0,0.3);
            padding: 8px 12px;
            border-radius: 8px;
        }
    </style>
</head>
<body>

    <div id="controls-container">
        <label for="iterations">Subdivisions:</label>
        <input type="range" id="iterations" min="0" max="1000" value="1" step="10">
        <div id="info">Points: 18</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CORE FUNCTION ---
        /**
         * Generates points evenly distributed on the surface of a sphere using recursive subdivision of an octahedron.
         * @param {number} subdivisions - The number of recursive subdivisions to perform. 0 means the base octahedron.
         * @param {number} [radius=1] - The radius of the sphere.
         * @returns {Array<Array<number>>} An array of points, where each point is an array [x, y, z].
         */
        /*function distributePointsOnSphere(subdivisions, radius = 1) {
            // Start with the 6 vertices of an octahedron, which are already on the unit sphere.
            let vertices = [
                [1, 0, 0], [-1, 0, 0], [0, 1, 0],
                [0, -1, 0], [0, 0, 1], [0, 0, -1]
            ];

            // Define the 8 triangular faces of the octahedron using the indices of the vertices.
            let faces = [
                [0, 4, 2], [0, 2, 5], [0, 5, 3], [0, 3, 4],
                [1, 2, 4], [1, 5, 2], [1, 3, 5], [1, 4, 3]
            ];

            // A cache to store the index of a newly created vertex for a given edge.
            // The key is a string representation of the edge (e.g., "1_4") to avoid duplicating vertices.
            const midpointCache = new Map();

            // This helper function finds or creates a vertex at the midpoint of an edge.
            const getMidpointVertex = (index1, index2) => {
                const key = Math.min(index1, index2) + '_' + Math.max(index1, index2);
                if (midpointCache.has(key)) {
                    return midpointCache.get(key);
                }

                // Get the coordinates of the two vertices.
                const v1 = vertices[index1];
                const v2 = vertices[index2];

                // Calculate the midpoint.
                const mid = [
                    (v1[0] + v2[0]) / 2,
                    (v1[1] + v2[1]) / 2,
                    (v1[2] + v2[2]) / 2
                ];

                // Normalize the midpoint vector to project it onto the surface of the unit sphere.
                const length = Math.sqrt(mid[0] ** 2 + mid[1] ** 2 + mid[2] ** 2);
                const normalizedMid = [mid[0] / length, mid[1] / length, mid[2] / length];

                // Add the new vertex to our list and cache its index.
                vertices.push(normalizedMid);
                const newIndex = vertices.length - 1;
                midpointCache.set(key, newIndex);

                return newIndex;
            };

            // Recursively subdivide the faces.
            for (let i = 0; i < subdivisions; i++) {
                const newFaces = [];
                midpointCache.clear(); // Clear cache for each subdivision level

                for (const face of faces) {
                    const v1 = face[0];
                    const v2 = face[1];
                    const v3 = face[2];

                    // Get the new vertices at the midpoint of each edge.
                    const a = getMidpointVertex(v1, v2);
                    const b = getMidpointVertex(v2, v3);
                    const c = getMidpointVertex(v3, v1);

                    // Replace the single large triangle with four smaller ones.
                    newFaces.push([v1, a, c]);
                    newFaces.push([v2, b, a]);
                    newFaces.push([v3, c, b]);
                    newFaces.push([a, b, c]);
                }
                faces = newFaces;
            }

            // Apply the final radius to all vertices.
            return vertices.map(v => [v[0] * radius, v[1] * radius, v[2] * radius]);
        }
        */

        /*
        function distributePointsOnSphere(subdivisions, radius = 1) {
            const vertices = new Array(subdivisions);
            const phi = Math.PI * (Math.sqrt(5) - 1); // Golden angle in radians.
            const n = subdivisions - 1;
            for ( let i = 0; i < subdivisions; i += 1 ) {
                const y = 1 - (i / n) * 2; // y goes from 1 to -1.
                const radius = Math.sqrt(1 - (y ** 2)); // Radius at y.
                const theta = phi * i; // Golden angel increment.
                const x = Math.cos(theta) * radius;
                const z = Math.sin(theta) * radius;
                vertices[i] = [x, y, z];
            }

            // Apply the final radius to all vertices.
            return vertices.map(v => [v[0] * radius, v[1] * radius, v[2] * radius]);
        }
        */
        
        /*
        function distributePointsOnSphere(subdivisions, radius = 1) {


             if ( subdivisions === 0 ) return [0, 0, 0]
             const vertices = [
                [0, 0, 1], // North pole.
      [0, 0, -1], // South pole.
      [1, 0, 0], // East
      [-1, 0, 0], // West
      [0, 1, 0], // North
      [0, -1, 0], // South
    ]   

            // Apply the final radius to all vertices.
            return vertices.map(v => [v[0] * radius, v[1] * radius, v[2] * radius]);
        }
        */
        
        
        function distributePointsOnSphere1(subdivisions, radius = 1) {
            const vertices = new Array(subdivisions);
            const goldenRatio = (1 + Math.sqrt(5)) / 2;
            const e = 2.5;
            const denom = subdivisions - 1 + (2 * e);
            
            for ( let i = 0; i < subdivisions; i += 1 ) {
                const tx = (i + e) / denom;
                const ty = i / goldenRatio;
                
                const theta = Math.acos(2*tx - 1) - (Math.PI / 2);
                const phi = 2 * Math.PI * ty;
                
                const x = Math.cos(theta) * Math.cos(phi);
                const y = Math.cos(theta) * Math.sin(phi);
                const z = Math.sin(theta);
                
                vertices[i] = [x, y, z];
            }

            vertices[0] = [0, 0, 1];
            vertices[subdivisions - 1] = [0, 0, -1];

            // Apply the final radius to all vertices.
            return vertices.map(v => [v[0] * radius, v[1] * radius, v[2] * radius]);
        }
        
        
        
     function distributePointsOnSphere(minPoints, radius = 1) {
       
        if ( minPoints <= 6 ) return distributePointsOnSphere1(minPoints, radius);
        
        // Store the initial triangulation. 0 and 1 are poles. 2â€“5 are E, W, N, S along equator.
        const center = [0, 0, 0];
        const radius2 = 1; // 1^2 = 1
        const pointsMap = new Map();
        const triSet = new Set();
        octahedron().forEach((pt, idx) => pointsMap.set(`${idx}`, pt));
        
        // Triangles are "a|b|c" where each letter is a point index.
        // Northern hemisphere.
        triSet.add("0|2|5"); // 0|W|S
        triSet.add("0|5|2"); // 0|S|E
        triSet.add("0|5|2"); // 0|E|N
        triSet.add("0|5|2"); // 0|N|W
        
        // Southern hemisphere.
        triSet.add("1|2|5"); // 1|W|S
        triSet.add("1|5|2"); // 1|S|E
        triSet.add("1|5|2"); // 1|E|N
        triSet.add("1|5|2"); // 1|N|W
        
        const addMidpoint = (aLabel, bLabel) => {
					const midLabel = `${aLabel}.${bLabel}`;
					if ( pointsMap.has(midLabel) ) return midLabel;
					
					// Get the point between a and b. 
					// Then extend a line from the center through that midpoint at radius length to locate new surface point.
					const a = pointsMap.get(aLabel);
					const b = pointsMap.get(bLabel);
					const mid = subtract(b, a);
					const newPt = towardsPoint(center, mid, radius);
					pointsMap.set(midLabel, newPt);
					return midLabel;
        }
        
        // Split all the triangles until reaching at least minPoints.
        while ( pointsMap.size < minPoints ) {
        const tris = [...triSet.values()]; // So the map can be updated.
            for ( const tri of tris ) {
                const [aLabel, bLabel, cLabel] = tri.split("|");
                const abLabel = addMidpoint(aLabel, bLabel);
                const bcLabel = addMidpoint(bLabel, cLabel);
                const caLabel = addMidpoint(cLabel, aLabel);
                
                // Delete the outer triangle
                triSet.delete(tri);
                
                // Add the new midpoint triangle
                triSet.add(`${abLabel}|${bcLabel}|${caLabel}`); 
                
                // Add 3 triangles; one from each corner of the original.
                triSet.add(`${abLabel}|${bcLabel}|${bLabel}`);
                triSet.add(`${bcLabel}|${caLabel}|${cLabel}`);
                triSet.add(`${caLabel}|${abLabel}|${aLabel}`);    
            }
        }
        // return [...pointsMap.values()]
        
        // Apply the final radius to all vertices.
        return [...pointsMap.values()].map(v => [v[0] * radius, v[1] * radius, v[2] * radius]);
    }
        
        function towardsPoint(a, b, distance) {
            const out = structuredClone(a);
            if ( !distance ) return out;
            const delta = structuredClone(a);
            delta[0] = b[0] - a[0];
            delta[1] = b[1] - a[1];
            delta[2] = b[2] - a[2];            
            const t = distance / magnitude(delta);
            return add(a, multiplyScalar(delta, t)); 
        }

        function magnitude(a) {
          return Math.hypot(...a);
        }

        function multiplyScalar(a, s) {
          const out = structuredClone(a);
          out[0] *= s;
          out[1] *= s;
          out[2] *= s;
          return out;
        } 
        
        function add(a, b) {
          const out = structuredClone(a);
          out[0] += b[0];
          out[1] += b[1];
          out[2] += b[2];
          return out;
        }
        
        function subtract(a, b) {
          const out = structuredClone(a);
          out[0] -= b[0];
          out[1] -= b[1];
          out[2] -= b[2];
          return out;
        }
        
				function octahedron() {
					return [
						[0, 0, 1],
						[0, 0, -1],
						[1, 0, 0],
						[-1, 0, 0],
						[0, 1, 0],
						[0, -1, 0],
					];
				}


        // --- 3D VISUALIZATION SETUP ---
        let scene, camera, renderer, controls;
        const pointsGroup = new THREE.Group();

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3.5;

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // Add a semi-transparent sphere for reference
            const sphereGeom = new THREE.SphereGeometry(1.5, 64, 64);
            const sphereMat = new THREE.MeshPhongMaterial({
                color: 0x007aff,
                transparent: true,
                opacity: 0.1,
                shininess: 50
            });
            const sphereMesh = new THREE.Mesh(sphereGeom, sphereMat);
            scene.add(sphereMesh);

            scene.add(pointsGroup);

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('iterations').addEventListener('input', (event) => {
                updatePoints(parseInt(event.target.value));
            });

            // Initial points generation
            updatePoints(parseInt(document.getElementById('iterations').value));
            
            animate();
        }

        function updatePoints(subdivisions) {
            // Clear previous points
            while (pointsGroup.children.length > 0) {
                pointsGroup.remove(pointsGroup.children[0]);
            }

            const points = distributePointsOnSphere(subdivisions, 1.5);

            // Update info display
            document.getElementById('info').textContent = `Points: ${points.length}`;

            // Create a small sphere mesh for each point
            const pointGeometry = new THREE.SphereGeometry(0.03, 16, 16);
            const pointMaterial = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, roughness: 0.5 });
            
            points.forEach(point => {
                const pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);
                pointMesh.position.set(point[0], point[1], point[2]);
                pointsGroup.add(pointMesh);
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
