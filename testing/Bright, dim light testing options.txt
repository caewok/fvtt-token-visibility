Options for detecting bright/dim/dark lighting/sound on target token:

1. Points
Test separately using X points on the token.

Pro:
• Simple, fast.
• Can increase resolution by testing multiple points.
• Can choose points on the token 3d surface to improve accuracy.
• Can choose points for the facing sides to improve accuracy.
• Use the 3d token bounds or a sphere instead of the exact token shape for simplicity, speed.

Con:
• Inexact.
• Not great with tiles.

2. Per light render using Geometry
Using either the 3d token bounds or the exact token shape, use the geometric method
to draw the bright/dim/dark portions of each token face from point of view of each light.

Must convert each face to the different perspective views.
--> Convert polygons to worldview and then to distinct camera view.

e.g.
Light 1: Convert token face(s) to light view; render; convert results back.
Light 2: Convert faces to light view; render; convert results back.
Light 3: Convert faces to light view; render; convert results back.
--> Now combine all 3 for each relevant face.
--> Then render from viewer, using the results of each face.

Pro:
• Geometry method is fast
• Can ignore unseen faces
• Can store face once created until token moves or scene objects change
• Exact
• No webGL

Con:
• Tokens move a lot, so storing the lit information not as useful
• Per light x per face rendering.
• Complex conversions and polygon combinations
• Performance?

3. BVH
Put all scene objects into a bvh. Probably using triangles.
When rendering target, test for light occlusion (and viewer occlusion) using the bvh.
Likely pass through lighting information as uniforms, and limit to X nearest lights.

Need a data texture for:
1. Walls
2. Tiles
3. Regions (this one is difficult unless storing only triangles)
4. Tokens (incl custom tokens, but that could get large)

Tiles: Limited number of textures can be used. Or use a texture array or combine multiple texture to one.

Pro:
• Accuracy.
• Handles occlusion from viewer and lights using same BVH.
• Only one render required.
• Can skip lights if occluded view or a bright light found.

Con:
• Data textures (at least 4).
• BVH is complex.
• Limits on handling tile exclusion. Alternative: Convert tiles to triangles as with geometric.
• Limits for number of lights to test.
• Performance takes a hit if many lights to test. Intersection test required.
• Probably need to make everything triangles for bvh, which will increase data required to pass through.


4. Per light render using cubemap templates (lightbox)

Render lighting separately as distinct views, like in #2. But store in render textures, combine
RTs into a cubemap.

Then when rendering the target, sample from the cubemap.

Pro:
• Can store face once created until token moves or scene objects change.
• Can render unlimited number of textures.
• Uses existing rendering approach, with vertices/indices.

Con:
• Tokens move a lot, so storing the lit information not as useful
• Per light x per face rendering.
• Conversion to cubemap could be quite complex, particularly when combining render for each light.

5. Raymarching
Store information about scene object positions but use sdfs to construct.
Use intersection information to determine tile UVs and transparency.
Likely pass through lighting information as uniforms, and limit to X nearest lights.

Pro:
• Accuracy.
• SDF is relatively straightforward and the shapes can be defined explicitly w/o triangles.
• May be useful for elevated shadow lighting.
• Much less data needed compared to the triangles of #3 (bvh) or #4 (cube maps).
• Can skip lights if occluded view or a bright light found..

Con:
• Textures remain complicated.
• Performance takes a hit if many lights to test.
• Performance may suffer given number of unique objects that must be combined for a scene.
  Essentially rendering the entire scene at every march step, for every fragment.

6. Combine Raymarching with #4 (cube templates)
Raymarch, but from each light perspective separately. Sample from the cubemap instead of
testing for X light intersections.



Current benchmarks:

This is the End (487 walls, no tiles)
points: 0.43 ms
geometric: 1.59 ms
perPixel: 14.09 ms
webGL2: 9.9 ms

Test Edges (w/ tiles)
points: 1.6 ms
geometric: 3.79 ms
perPixel: 61.96 ms
webGL2: 35.61 ms

If we had 5 lights hitting any given token, then could need:
5 x 3 faces = 15 renders

This is the End
points: ??
geometric per face: 1.59 + 1.59*15 = 9.54 ms
perPixel: 14.09 ms
webGL2 w/ BVH: > 9.9 ms
webGL2 w/ cubemap: 9.9ms + 9.9 * 15 = 158.4 ms
webGL2 w/ Raymarching: ??

Test Edges (w/ tiles)
 points: ??
geometric per face: 3.79 + 3.79*15 = 60.84 ms
perPixel: 14.09 ms
webGL2 w/ BVH: > 35.61 ms
webGL2 w/ cubemap: 35.61ms + 35.61 * 15 = 213.66 ms
webGL2 w/ Raymarching: ??

--> Probably not worth pursuing cubemaps given that tokens move a lot.
A given token moving would require:
- Redraw cubemaps: 213.66 ms
- Test each viewing token: 35.61ms * number of Tokens
--> If 10 tokens, at 569 ms

Versus BVH:
- Test each token. So can take up to 56.9 ms per token before cubemaps is better.
  Nearly double the time.



